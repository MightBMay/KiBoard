.TH "MidiInput" 3 "Version 1.0.0" "KiBoard GDD & Technical Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MidiInput
.SH SYNOPSIS
.br
.PP
.PP
Inherits MonoBehaviour\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBLoadScenePreview\fP (string sceneName)"
.br
.RI "Loads a preview of selected song into the \fBcurrentPreview\fP Scene variable, and begins playing the songs preview\&. "
.ti -1c
.RI "void \fBLoadSongFromCurrentSettings\fP (bool isPreview=false)"
.br
.RI "Loads the selected song for gameplay\&. "
.ti -1c
.RI "void \fBHookMidiDevice\fP ()"
.br
.RI "Hooks midi devices to be used for input\&. "
.ti -1c
.RI "void \fBUnHookMidiDevice\fP ()"
.br
.RI "unhooks midi devices to remove their input\&. "
.ti -1c
.RI "\fBNoteEventDataWrapper\fP \fBGetNoteEventWrapperFromSelectedSong\fP ()"
.br
.ti -1c
.RI "void \fBStartSongCoroutine\fP ()"
.br
.RI "called to begin playing the song\&. "
.ti -1c
.RI "IEnumerator \fBStartSong\fP (bool isPreview=false)"
.br
.RI "Starts playing the loaded song using the current \fBFileGroup\fP's mp3 file field\&. "
.ti -1c
.RI "IEnumerator \fBStartSong\fP (string mp3Path, bool isPreview=false)"
.br
.RI "Starts playing the loaded song from a given file path\&. "
.ti -1c
.RI "IEnumerator \fBStartSong\fP (List< \fBNoteEventInfo\fP > loadEvents, bool isPreview=false)"
.br
.RI "Starts playing a specified list of \fBNoteEventInfo\fP "
.ti -1c
.RI "void \fBStopSong\fP ()"
.br
.RI "Stops the currently playing song\&. "
.ti -1c
.RI "void \fBOnNoteSuccess\fP (ref string score, int note, float timing, \fBNoteEventInfo\fP storedNote)"
.br
.RI "Handles successful note presses\&. "
.ti -1c
.RI "bool \fBIsNoteCorrect\fP (int noteNumber, float timing, \fBNoteEventInfo\fP storedNote)"
.br
.RI "Check if note is was played at a correct timing\&. "
.ti -1c
.RI "void \fBRetryCurrentSong\fP ()"
.br
.RI "Reloads the currently playing song\&. "
.ti -1c
.RI "bool \fBGetAnyNoteActive\fP ()"
.br
.RI "Checks for pressed keys in the 8-key keyboard layout\&. "
.ti -1c
.RI "string \fBGetTimingScore\fP (float timing)"
.br
.RI "Gets the timing score based on the timing difference\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "List< \fBNoteEventInfo\fP > \fBstoredNoteEvents\fP"
.br
.RI "Currently loaded notes for the selected song\&. "
.ti -1c
.RI "Coroutine \fBPrepareNotesCoroutine\fP"
.br
.RI "Reference to the \fBGameManager\&.PrepareNotes(float, List<NoteEventInfo>, bool)\fP prepareNotes Coroutine\&. "
.ti -1c
.RI "bool \fBisPedalPressed\fP"
.br
.RI "Is the pedal pressed\&. "
.ti -1c
.RI "bool[] \fBenabledKeys\fP = new bool[88]"
.br
.RI "array of bools corresponding to currently activated keys\&. "
.ti -1c
.RI "bool \fBtakeInput\fP = true"
.br
.RI "Should the game take piano input\&. "
.ti -1c
.RI "bool \fBinGame\fP = false"
.br
.RI "Are we in the game scene\&. "
.ti -1c
.RI "bool \fBisMidiHooked\fP"
.br
.RI "are midi devices hooked?
.br
 \fBHookMidiDevice\fP and \fBUnHookMidiDevice\fP\&. "
.ti -1c
.RI "RenderTexture \fBrenderTexture\fP"
.br
.RI "Render texture used for previewing scenes in Song Selection\&. "
.ti -1c
.RI "Scene \fBcurrentPreview\fP"
.br
.RI "Scene used for previewing songs in Song Selection\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBMidiInput\fP \fBinstance\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBAwake\fP ()"
.br
.ti -1c
.RI "void \fBUpdate\fP ()"
.br
.ti -1c
.RI "void \fBPedalStateChanged\fP (MidiChannel channel, int knobNumber, float knobValue)"
.br
.RI "Handles MIDI sustain pedal state changes\&. "
.ti -1c
.RI "void \fBNoteOn\fP (MidiChannel channel, int note, float velocity)"
.br
.RI "Handles MIDI note on events\&. "
.ti -1c
.RI "void \fBNoteOff\fP (MidiChannel channel, int note)"
.br
.RI "Handles MIDI note off events\&. "
.ti -1c
.RI "void \fBCheckNotesKeyboard12\fP ()"
.br
.RI "Checks for pressed keys in the 12-key keyboard layout\&. "
.ti -1c
.RI "float \fBGetTimeDifference\fP (float storedTiming)"
.br
.RI "Calculates the time difference between the stored timing and the current song time\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "GameObject \fBimagePrefab\fP"
.br
.RI "prefab object with a RawImage component to assign \fBrenderTexture\fP to\&. "
.ti -1c
.RI "Dictionary< KeyCode, int > \fBkeyboard12\fP"
.br
.RI "Dictionary mapping for Computer keyboard input to note input\&. "
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void MidiInput\&.Awake ()\fR [private]\fP"

.nf
82     {
83         if (instance == null)
84         {
85             instance = this;
86             DontDestroyOnLoad(gameObject);
87         }
88         else { Destroy(gameObject); }
89     }
.PP
.fi

.SS "void MidiInput\&.CheckNotesKeyboard12 ()\fR [private]\fP"

.PP
Checks for pressed keys in the 12-key keyboard layout\&. 
.nf
481     {
482         // Check for computer keyboard key presses and releases
483         foreach (var keyValuePair in keyboard12)
484         {
485             KeyCode key = keyValuePair\&.Key;
486             int noteNumber = keyValuePair\&.Value;
487 
488             if (Input\&.GetKeyDown(key))
489             {
490                 // Simulate Note On event for the pressed key
491                 NoteOn(MidiChannel\&.All, noteNumber, 1\&.0f);
492             }
493 
494             if (Input\&.GetKeyUp(key))
495             {
496                 // Simulate Note Off event for the released key
497                 NoteOff(MidiChannel\&.All, noteNumber);
498             }
499         }
500     }
.PP
.fi

.PP
Referenced by \fBUpdate()\fP\&.
.SS "bool MidiInput\&.GetAnyNoteActive ()"

.PP
Checks for pressed keys in the 8-key keyboard layout\&. Checks if any note is currently active (pressed)\&.
.PP
\fBReturns\fP
.RS 4
True if any note is active, otherwise false\&.
.RE
.PP

.nf
511     {
512         foreach (bool b in enabledKeys)
513         {
514             if (b)
515             {
516                 return true;
517             }
518         }
519         return false;
520     }
.PP
.fi

.SS "\fBNoteEventDataWrapper\fP MidiInput\&.GetNoteEventWrapperFromSelectedSong ()"

.PP
\fBReturns\fP
.RS 4
\fBNoteEventDataWrapper\fP loaded from the currently selected song
.RE
.PP

.nf
310     {
311         NoteEventDataWrapper data = MidiReadFile\&.GetNoteEventsFromFilePath(GameSettings\&.currentSongPath);
312         if (data == null) { Debug\&.Log("Error Reading data from path: " + GameSettings\&.currentSongPath); return null; }
313         storedNoteEvents = data\&.NoteEvents;
314         return data;
315     }
.PP
.fi

.SS "float MidiInput\&.GetTimeDifference (float storedTiming)\fR [private]\fP"

.PP
Calculates the time difference between the stored timing and the current song time\&. 
.PP
\fBParameters\fP
.RS 4
\fIstoredTiming\fP The stored timing value\&.
.RE
.PP
\fBReturns\fP
.RS 4
The time difference\&.
.RE
.PP

.nf
528     {
529         // Adjust this threshold based on your timing accuracy requirements
530         // float timingThreshold = currentSettings\&.timeInterval;
531 
532         // Check if the received timing is within a certain threshold of the stored timing
533         //0\&.125f leniancy
534         return Mathf\&.Abs( (GameManager\&.instance\&.songTime + PlayerSettings\&.inputDelay)  \- 0\&.125f \- storedTiming);
535     }
.PP
.fi

.PP
Referenced by \fBNoteOn()\fP\&.
.SS "string MidiInput\&.GetTimingScore (float timing)"

.PP
Gets the timing score based on the timing difference\&. 
.PP
\fBParameters\fP
.RS 4
\fItiming\fP The timing difference\&.
.RE
.PP
\fBReturns\fP
.RS 4
The timing score (e\&.g\&., 'Perfect', 'Good', 'Okay', 'Miss')\&.
.RE
.PP

.nf
542     {
543         if (timing < 0\&.1f) { return "Perfect"; }
544         else if (timing < 0\&.175f) { return "Good"; }
545         else if (timing < 0\&.275f) { return "Okay"; }
546         else { return "Miss"; }
547     }
.PP
.fi

.PP
Referenced by \fBNoteOn()\fP, and \fBOnNoteSuccess()\fP\&.
.SS "void MidiInput\&.HookMidiDevice ()"

.PP
Hooks midi devices to be used for input\&. 
.nf
269     {
270         try
271         {
272             if (isMidiHooked) { Debug\&.Log("Midi Already Hooked"); return; }
273             MidiMaster\&.noteOnDelegate += NoteOn;
274             MidiMaster\&.noteOffDelegate += NoteOff;
275             MidiMaster\&.knobDelegate += PedalStateChanged;
276             isMidiHooked = true;
277         }
278         catch
279         {
280             isMidiHooked = false;
281             Debug\&.Log("Error Hooking midi device");
282         }
283     }
.PP
.fi

.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP\&.
.SS "bool MidiInput\&.IsNoteCorrect (int noteNumber, float timing, \fBNoteEventInfo\fP storedNote)"

.PP
Check if note is was played at a correct timing\&. 
.PP
\fBParameters\fP
.RS 4
\fInoteNumber\fP Number of the note played\&.
.br
\fItiming\fP What time the note was hit\&.
.br
\fIstoredNote\fP Note that is being compared to\&.
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.nf
445     {
446         if (GameSettings\&.usePiano) { return noteNumber == storedNote\&.noteNumber && !storedNote\&.triggered && timing < 0\&.5f; }
447         return noteNumber % 12 == storedNote\&.noteNumber % 12 && !storedNote\&.triggered && timing < 0\&.5f;
448 
449     }
.PP
.fi

.PP
Referenced by \fBNoteOn()\fP\&.
.SS "void MidiInput\&.LoadScenePreview (string sceneName)"

.PP
Loads a preview of selected song into the \fBcurrentPreview\fP Scene variable, and begins playing the songs preview\&. 
.PP
\fBParameters\fP
.RS 4
\fIsceneName\fP 
.RE
.PP

.nf
128     {
129 
130         if (currentPreview\&.isLoaded)
131         {
132             SceneManager\&.UnloadSceneAsync(currentPreview);
133         }
134         AsyncOperation loadOperation = SceneManager\&.LoadSceneAsync(sceneName, LoadSceneMode\&.Additive);
135         loadOperation\&.completed += (operation) =>
136         {
137             currentPreview = SceneManager\&.GetSceneByName(sceneName); // Assign the loaded scene to currentPreview
138             OnSceneLoaded(operation);
139         };
140 
141 
142         void OnSceneLoaded(AsyncOperation asyncOperation)
143         {
144 
145             Scene previewScene = SceneManager\&.GetSceneByName(sceneName);
146 
147 
148             // Iterate through the root game objects of the scene
149             foreach (GameObject rootObject in previewScene\&.GetRootGameObjects())
150             {
151                 if (rootObject\&.TryGetComponent(out TransitionManager transition))
152                 {
153                     transition\&.GetComponent<Canvas>()\&.enabled = false;
154                 }
155                 if (rootObject\&.TryGetComponent(out Canvas canvas))
156                 {
157                     canvas\&.enabled = false;
158                 }
159                 // Assign the object to the "PreviewLayer"
160                 AssignToPreviewLayer(rootObject);
161 
162                 // Check if the object has an EventSystem component and destroy it
163                 if (rootObject\&.TryGetComponent(out EventSystem eventSystem))
164                 {
165                     Destroy(eventSystem\&.gameObject);
166                 }
167 
168                 // Find the camera in the preview scene
169                 Camera camera = rootObject\&.GetComponentInChildren<Camera>();
170                 if (camera != null)
171                 {
172 
173                     // Set the camera to render to the specified RenderTexture
174                     camera\&.cullingMask = 1 << LayerMask\&.NameToLayer("PreviewLayer");
175                     camera\&.targetTexture = renderTexture;
176                 }
177             }
178 
179             // Create a new UI Image object
180             GameObject imageObject = Instantiate(imagePrefab, UiHolder\&.instance\&.transform);
181             RawImage image = imageObject\&.GetComponentInChildren<RawImage>(); // CAN ONLY DO THIS BECAUSE IT IS RAWIMAGE, SINCE I USE MANY NORMAL IMAGE TYPES\&.
182 
183 
184             // Check if RawImage component exists
185             if (image != null)
186             {
187                 // Assign the RenderTexture to the RawImage component's texture
188                 image\&.texture = renderTexture;
189                 if (UiHolder\&.instance\&.scenePreview != null) { Destroy(UiHolder\&.instance\&.scenePreview); }
190                 UiHolder\&.instance\&.scenePreview = imageObject;
191             }
192             else
193             {
194                 Debug\&.LogError("RawImage component not found on the instantiated image prefab\&.");
195             }
196             asyncOperation\&.completed \-= OnSceneLoaded;
197 
198         }
199 
200         // Method to assign an object and its children to the "PreviewLayer"
201         void AssignToPreviewLayer(GameObject obj)
202         {
203             // Assign the object to the "PreviewLayer"
204             obj\&.layer = LayerMask\&.NameToLayer("PreviewLayer");
205 
206             // Recursively assign children to the "PreviewLayer"
207             foreach (Transform child in obj\&.transform)
208             {
209                 AssignToPreviewLayer(child\&.gameObject);
210             }
211         }
212     }
.PP
.fi

.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP\&.
.SS "void MidiInput\&.LoadSongFromCurrentSettings (bool isPreview = \fRfalse\fP)"

.PP
Loads the selected song for gameplay\&. 
.nf
221     {
222         MP3Handler\&.instance\&.StopMusic();
223         string gameMode;
224         if (KiboardDebug\&.isMidiConnected && GameSettings\&.usePiano) { gameMode = "GameScene88"; } else { gameMode = "GameScene12"; }
225 
226         if (isPreview)
227         {
228             LoadScenePreview(gameMode);
229             NoteEventDataWrapper data = MidiReadFile\&.GetNoteEventsFromFilePath(GameSettings\&.currentSongPath);
230             GameSettings\&.bpm = data\&.BPM;
231             storedNoteEvents = data\&.NoteEvents;
232             takeInput = false;
233             inGame = false;
234             StartCoroutine(StartSong(true));
235         }
236         else
237         {
238 
239             try
240             {
241                 TransitionManager\&.instance\&.LoadNewScene(gameMode);
242             }
243 
244             catch(Exception e)
245             {
246                 Debug\&.Log(e);
247                 SceneManager\&.LoadScene(gameMode);
248             }
249 
250             if (GameSettings\&.usePiano) { HookMidiDevice(); } else { UnHookMidiDevice(); }
251             NoteEventDataWrapper data = MidiReadFile\&.GetNoteEventsFromFilePath(GameSettings\&.currentSongPath);
252             GameSettings\&.bpm = GameSettings\&.bpm == 0 ? data\&.BPM : GameSettings\&.bpm;
253 
254             storedNoteEvents = data\&.NoteEvents;
255             takeInput = true;
256             inGame = true;
257             if (PrepareNotesCoroutine != null) StopCoroutine(PrepareNotesCoroutine);
258             GameManager\&.instance\&.StopReadiedNotes();
259             StartCoroutine(StartSong());
260         }
261 
262 
263 
264     }
.PP
.fi

.PP
Referenced by \fBRetryCurrentSong()\fP\&.
.SS "void MidiInput\&.NoteOff (MidiChannel channel, int note)\fR [private]\fP"

.PP
Handles MIDI note off events\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP The MIDI channel\&.
.br
\fInote\fP The MIDI note number\&.
.RE
.PP

.nf
458     {
459         if (!takeInput || isPedalPressed) { return; }
460         if (inGame)
461         {
462             SpawnPiano\&.instance\&.UpdateKeyColours(note \- 21, false);
463             Replay\&.UpdateReplay(note, GameManager\&.instance\&.songTime);
464         }
465         enabledKeys[note \- 21] = false;
466 
467     }
.PP
.fi

.PP
Referenced by \fBCheckNotesKeyboard12()\fP, \fBHookMidiDevice()\fP, and \fBUnHookMidiDevice()\fP\&.
.SS "void MidiInput\&.NoteOn (MidiChannel channel, int note, float velocity)\fR [private]\fP"

.PP
Handles MIDI note on events\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP The MIDI channel\&.
.br
\fInote\fP The MIDI note number\&.
.br
\fIvelocity\fP The note velocity\&.
.RE
.PP

.nf
387     {
388         if (!takeInput) { return; }
389         // Check if the received note and timing match any stored events
390         if (inGame)
391         {
392             string score = "";
393             float timing = Mathf\&.Infinity;
394             foreach (NoteEventInfo storedNote in storedNoteEvents)
395             {
396                 if (storedNoteEvents == null) { return; }
397                 timing = GetTimeDifference(storedNote\&.startTime);
398                 if (IsNoteCorrect(note, timing, storedNote))
399                 {
400                     OnNoteSuccess(ref score, note, timing, storedNote);
401                     break;  // Exit the loop after the first match
402 
403                 }
404 
405             }
406 
407             score ??= GetTimingScore(timing);
408             GameManager\&.instance\&.combo\&.ChangeMultiplier(score);
409 
410             SpawnPiano\&.instance\&.UpdateKeyColours(note \- 21, true, score);
411             if (GameManager\&.instance\&.songTime >= 0)
412             {
413                 GameManager\&.instance\&.UpdatePlayerScore(score);
414             }
415             Replay\&.UpdateReplay(note, GameManager\&.instance\&.songTime);
416         }
417         enabledKeys[note \- 21] = true;
418 
419 
420 
421         
422     }
.PP
.fi

.PP
Referenced by \fBCheckNotesKeyboard12()\fP, \fBHookMidiDevice()\fP, and \fBUnHookMidiDevice()\fP\&.
.SS "void MidiInput\&.OnNoteSuccess (ref string score, int note, float timing, \fBNoteEventInfo\fP storedNote)"

.PP
Handles successful note presses\&. 
.PP
\fBParameters\fP
.RS 4
\fIscore\fP 
.br
\fInote\fP 
.br
\fItiming\fP 
.br
\fIstoredNote\fP 
.RE
.PP

.nf
432     {
433         score = GetTimingScore(timing);
434         SpawnPiano\&.instance\&.SpawnKeyParticle(note \- 21, score);
435         storedNote\&.triggered = true;
436     }
.PP
.fi

.PP
Referenced by \fBNoteOn()\fP\&.
.SS "void MidiInput\&.PedalStateChanged (MidiChannel channel, int knobNumber, float knobValue)\fR [private]\fP"

.PP
Handles MIDI sustain pedal state changes\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP The MIDI channel\&.
.br
\fIknobNumber\fP The knob number\&.
.br
\fIknobValue\fP The knob value\&.
.RE
.PP

.nf
109     {
110         if (knobNumber == 64 && knobValue > 0\&.5f)
111         {
112             isPedalPressed = true;
113 
114         }
115         else
116         {
117             isPedalPressed = false;
118             try { SpawnPiano\&.instance\&.ClearAllKeyColours(); }
119             catch { }
120         }
121     }
.PP
.fi

.PP
Referenced by \fBHookMidiDevice()\fP, and \fBUnHookMidiDevice()\fP\&.
.SS "void MidiInput\&.RetryCurrentSong ()"

.PP
Reloads the currently playing song\&. 
.nf
472     {
473         UnHookMidiDevice();
474         LoadSongFromCurrentSettings(false);
475     }
.PP
.fi

.SS "IEnumerator MidiInput\&.StartSong (bool isPreview = \fRfalse\fP)"

.PP
Starts playing the loaded song using the current \fBFileGroup\fP's mp3 file field\&. 
.PP
\fBReturns\fP
.RS 4

.RE
.PP

.nf
328     {
329 
330         GameManager\&.instance\&.currentSongScore\&.ClearScore();
331         GameManager\&.instance\&.combo\&.ClearCombo();
332         yield return PrepareNotesCoroutine = StartCoroutine(GameManager\&.instance\&.PrepareNotes(GameSettings\&.bpm, storedNoteEvents, isPreview));
333         StartCoroutine(MP3Handler\&.instance\&.PlaySong(SongSelection\&.GetUnderscoreSubstring(GameSettings\&.currentFileGroup\&.Mp3File)));
334     }
.PP
.fi

.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP, and \fBStartSongCoroutine()\fP\&.
.SS "IEnumerator MidiInput\&.StartSong (List< \fBNoteEventInfo\fP > loadEvents, bool isPreview = \fRfalse\fP)"

.PP
Starts playing a specified list of \fBNoteEventInfo\fP 
.PP
\fBParameters\fP
.RS 4
\fIloadEvents\fP The list of note events to play\&.
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.nf
353     {
354         GameManager\&.instance\&.currentSongScore\&.ClearScore();
355         var bpm = GameSettings\&.bpm;
356         loadEvents\&.ForEach(noteEvent => noteEvent\&.noteNumber += 20); // i \- for the fucking life of me\- cannot figure out why directly processing the midi files makes the note numbers
357                                                                      // 20 higher, but i have to do this to match that with the song editor\&.
358         yield return PrepareNotesCoroutine = StartCoroutine(GameManager\&.instance\&.PrepareNotes(GameSettings\&.bpm, storedNoteEvents, isPreview));
359 
360         StartCoroutine(MP3Handler\&.instance\&.PlaySong(GameSettings\&.currentSongPath));
361 
362     }
.PP
.fi

.SS "IEnumerator MidiInput\&.StartSong (string mp3Path, bool isPreview = \fRfalse\fP)"

.PP
Starts playing the loaded song from a given file path\&. 
.PP
\fBReturns\fP
.RS 4

.RE
.PP

.nf
340     {
341 
342         GameManager\&.instance\&.currentSongScore\&.ClearScore();
343         GameManager\&.instance\&.combo\&.ClearCombo();
344         yield return PrepareNotesCoroutine = StartCoroutine(GameManager\&.instance\&.PrepareNotes(GameSettings\&.bpm, storedNoteEvents, isPreview));
345         StartCoroutine(MP3Handler\&.instance\&.PlaySong(mp3Path));
346     }
.PP
.fi

.SS "void MidiInput\&.StartSongCoroutine ()"

.PP
called to begin playing the song\&. 
.nf
320     {
321         StartCoroutine(StartSong());
322     }
.PP
.fi

.SS "void MidiInput\&.StopSong ()"

.PP
Stops the currently playing song\&. 
.nf
368     {
369         if (GameManager\&.instance\&.isCurSongPreview) { return; }
370         GameManager\&.instance\&.StopSong();
371         StopCoroutine(PrepareNotesCoroutine);
372         MP3Handler\&.instance\&.StopMusic();
373 
374         GameSettings\&.ResetSettings(false);
375         GameManager\&.instance\&.ReturnToSongSelection();
376 
377 
378     }
.PP
.fi

.PP
Referenced by \fBUpdate()\fP\&.
.SS "void MidiInput\&.UnHookMidiDevice ()"

.PP
unhooks midi devices to remove their input\&. 
.nf
288     {
289         
290         try
291         {
292             MidiMaster\&.noteOnDelegate \-= NoteOn;
293             MidiMaster\&.noteOffDelegate \-= NoteOff;
294             MidiMaster\&.knobDelegate \-= PedalStateChanged;
295             isMidiHooked = false;
296         }
297         catch
298         {
299             isMidiHooked = false;
300             Debug\&.Log("Error Unhooking midi device");
301         }
302     }
.PP
.fi

.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP, and \fBRetryCurrentSong()\fP\&.
.SS "void MidiInput\&.Update ()\fR [private]\fP"

.nf
92     {
93         if (Input\&.GetKeyDown(KeyCode\&.Escape))
94         {
95             StopSong();
96         }
97         CheckNotesKeyboard12();
98         //CheckNotesKeyboard8();
99 
100     }
.PP
.fi

.SH "Member Data Documentation"
.PP 
.SS "Scene MidiInput\&.currentPreview"

.PP
Scene used for previewing songs in Song Selection\&. 
.PP
Referenced by \fBLoadScenePreview()\fP\&.
.SS "bool [] MidiInput\&.enabledKeys = new bool[88]"

.PP
array of bools corresponding to currently activated keys\&. 
.PP
Referenced by \fBGetAnyNoteActive()\fP, \fBNoteOff()\fP, and \fBNoteOn()\fP\&.
.SS "GameObject MidiInput\&.imagePrefab\fR [private]\fP"

.PP
prefab object with a RawImage component to assign \fBrenderTexture\fP to\&. 
.PP
Referenced by \fBLoadScenePreview()\fP\&.
.SS "bool MidiInput\&.inGame = false"

.PP
Are we in the game scene\&. 
.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP, \fBNoteOff()\fP, and \fBNoteOn()\fP\&.
.SS "\fBMidiInput\fP MidiInput\&.instance\fR [static]\fP"

.PP
Referenced by \fBGameManager\&.AssignToPreviewLayer()\fP, \fBAwake()\fP, \fBMainMenuLoad\&.LoadToSongSelect()\fP, \fBGameManager\&.PrepareNotes()\fP, and \fBGameManager\&.ReturnToSongSelection()\fP\&.
.SS "bool MidiInput\&.isMidiHooked"

.PP
are midi devices hooked?
.br
 \fBHookMidiDevice\fP and \fBUnHookMidiDevice\fP\&. 
.PP
Referenced by \fBHookMidiDevice()\fP, and \fBUnHookMidiDevice()\fP\&.
.SS "bool MidiInput\&.isPedalPressed"

.PP
Is the pedal pressed\&. 
.PP
Referenced by \fBNoteOff()\fP, and \fBPedalStateChanged()\fP\&.
.SS "Dictionary<KeyCode, int> MidiInput\&.keyboard12\fR [private]\fP"
\fBInitial value:\fP
.nf
= new Dictionary<KeyCode, int>
    {
        { KeyCode\&.A, 48 },
        { KeyCode\&.W, 49 },
        { KeyCode\&.S, 50 },
        { KeyCode\&.E, 51 },
        { KeyCode\&.D, 52 },
        { KeyCode\&.F, 53 },
        { KeyCode\&.T, 54 },
        { KeyCode\&.G, 55 },
        { KeyCode\&.Y, 56 },
        { KeyCode\&.H, 57 },
        { KeyCode\&.U, 58 },
        { KeyCode\&.J, 59 },
    }
.PP
.fi

.PP
Dictionary mapping for Computer keyboard input to note input\&. 
.nf
60     {
61         { KeyCode\&.A, 48 },
62         { KeyCode\&.W, 49 },
63         { KeyCode\&.S, 50 },
64         { KeyCode\&.E, 51 },
65         { KeyCode\&.D, 52 },
66         { KeyCode\&.F, 53 },
67         { KeyCode\&.T, 54 },
68         { KeyCode\&.G, 55 },
69         { KeyCode\&.Y, 56 },
70         { KeyCode\&.H, 57 },
71         { KeyCode\&.U, 58 },
72         { KeyCode\&.J, 59 },
73     };
.PP
.fi

.PP
Referenced by \fBCheckNotesKeyboard12()\fP\&.
.SS "Coroutine MidiInput\&.PrepareNotesCoroutine"

.PP
Reference to the \fBGameManager\&.PrepareNotes(float, List<NoteEventInfo>, bool)\fP prepareNotes Coroutine\&. 
.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP, \fBStartSong()\fP, \fBStartSong()\fP, \fBStartSong()\fP, and \fBStopSong()\fP\&.
.SS "RenderTexture MidiInput\&.renderTexture"

.PP
Render texture used for previewing scenes in Song Selection\&. 
.PP
Referenced by \fBLoadScenePreview()\fP\&.
.SS "List<\fBNoteEventInfo\fP> MidiInput\&.storedNoteEvents"

.PP
Currently loaded notes for the selected song\&. 
.PP
Referenced by \fBGetNoteEventWrapperFromSelectedSong()\fP, \fBLoadSongFromCurrentSettings()\fP, \fBNoteOn()\fP, \fBStartSong()\fP, \fBStartSong()\fP, and \fBStartSong()\fP\&.
.SS "bool MidiInput\&.takeInput = true"

.PP
Should the game take piano input\&. 
.PP
Referenced by \fBLoadSongFromCurrentSettings()\fP, \fBNoteOff()\fP, and \fBNoteOn()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for KiBoard GDD & Technical Documentation from the source code\&.
